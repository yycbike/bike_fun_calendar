<?php
# Functions related to creating & updating calendar events.
#
# This is a loose port of calform.php & calsubmit.php from the old
# site.
#
# Todos:
# - Test new event creation
# - Test update of existing events

global $wpdb;

class BfcEventSubmission {
    # Arguments for events (to pass on to the database)
    protected $event_args = Array();

    # DB id of the event. Unset when action is new.
    protected $event_id;
    
    # new    = show blank form for creating a new object
    # create = commit the results from a new 
    # edit   = show filled-in form for editing the event
    # update = commit the results from an edit
    # delete = delete the event (with no confirmation)
    protected $action;

    protected $errors = Array();

    protected $dayinfo;

    # About editcodes
    #
    # In order to modify an existing event, the user needs to
    # provide both an ID and an editcode. This prvents people from
    # editing someone else's event through URL hacking.
    #
    # An editcode is required for these actions: edit, update,
    # and delete.
    protected $user_editcode;
    protected $db_editcode;

    # Information about the database fields we'll be populating.
    # Keys are names of the fields.
    #
    # - type: %s or %d, used when generating the SQL statements to
    #   populate the database.
    #
    # - missing_val: A value to use if the field is missing from
    #   $wp_query. These are not default values. Rather, this overcomes
    #   these limitations in form processing: (1) WordPress doesn't
    #   populate $wp_query->query_vars[] for values that are passed in
    #   from the form, but blank. (2) When a checkbox is unchecked, the
    #   web browser doesn't even send over form data. We have to notice
    #   it's unchecked by the lack of a value. 
    #
    # @@@ in the database hidecontact, printcontact, etc. are
    # integers, but we get them in as a string.
    protected $calevent_field_info = Array(
        "id"              => array("type" => "%d"),
        # editcode is a special case, it's generated
        # internally upon create.
        "editcode"        => array("type" => "%s"),
        "name"            => array("type" => "%s", "missing_val" => ""),
        "email"           => array("type" => "%s", "missing_val" => ""),
        "hideemail"       => array("type" => "%d", "missing_val" => "N"),
        "emailforum"      => array("type" => "%d", "missing_val" => "N"),
        "printemail"      => array("type" => "%d", "missing_val" => "N"),
        "phone"           => array("type" => "%s", "missing_val" => ""),
        "hidephone"       => array("type" => "%d", "missing_val" => ""),
        "printphone"      => array("type" => "%d", "missing_val" => "N"),
        "weburl"          => array("type" => "%s", "missing_val" => ""),
        "webname"         => array("type" => "%s", "missing_val" => ""),
        "printweburl"     => array("type" => "%d", "missing_val" => "N"),
        "contact"         => array("type" => "%s", "missing_val" => ""),
        "hidecontact"     => array("type" => "%d", "missing_val" => "N"),
        "printcontact"    => array("type" => "%d", "missing_val" => "N"),
        "title"           => array("type" => "%s", "missing_val" => ""),
        "tinytitle"       => array("type" => "%s", "missing_val" => ""),
        "audience"        => array("type" => "%s", "missing_val" => ""),
        "descr"           => array("type" => "%s", "missing_val" => ""),
        "printdescr"      => array("type" => "%s", "missing_val" => ""),
        "dates"           => array("type" => "%s", "missing_val" => ""),
        # datestype is generated by the code, not input from the form,
        # so don't set a missing_val for it.
        "datestype"       => array("type" => "%s"),
        "eventtime"       => array("type" => "%s", "missing_val" => ""),
        "eventduration"   => array("type" => "%d", "missing_val" => 0),
        "timedetails"     => array("type" => "%s", "missing_val" => ""),
        "locname"         => array("type" => "%s", "missing_val" => ""),
        "address"         => array("type" => "%s", "missing_val" => ""),
        # Unlike other booleans, addressverified has type char(1)
        "addressverified" => array("type" => "%s", "missing_val" => "N"),
        "locdetails"      => array("type" => "%s", "missing_val" => ""),

        # No missing_vals for image fields, because they come through the
        # file upload process.
        "image"           => array("type" => "%s"),
        "imagewidth"      => array("type" => "%d"),
        "imageheight"     => array("type" => "%d"),

        # Evan isn't sure yet what the right missing_val is for review,
        # so leave it alone for now.
        "review"          => array("type" => "%s"),
        );

    protected $caldaily_field_info = Array(
        "id"          => array("type" => "%d"),
        "newsflash"   => array("type" => "%s", "missing_val" => ""),
        "eventstatus" => array("type" => "%s"),
        "eventdate"   => array("type" => "%s"),
        "exceptionid" => array("type" => "%d"),
        );
    
    public function __construct() {
        global $wp_query;
        $query_vars = $wp_query->query_vars;

        # Query-supplied arguments for the caldaily form
        $daily_args = Array();
        
        if (isset($query_vars['calform_event_id'])) {
            $this->event_id = (int) $query_vars['calform_event_id'];
        }

        if (isset($query_vars['calform_action'])) {
            $this->action = $query_vars['calform_action'];
        }

        # If we haven't set an action, default to new.
        if (!isset($this->action)) {
            $this->action = 'new';
        }

        # If we're editing an existing object, grab it from the db.
        # Do this before we load the rest of the query vars, so that
        # user-specified values can override the database.
        if ($this->action == "edit") {
            $this->load_from_db();
        }
        else if ($this->action == "update"   ||
                 $this->action == "delete") {
            $this->load_modification_fields_from_db();
        }
        
        # Process arguments for caldaily
        foreach ($query_vars as $query_name => $query_value) {
            $regex_matches = array();
            if (preg_match('/event_(newsflash|status)(.*)/',
                $query_name, $regex_matches)) {

                # This is an argument for the caldaily table.
                # File it separately from the other arguments.
                $type        = $regex_matches[1];
                $date_suffix = $regex_matches[2];

                $daily_args[$date_suffix][$type] = $query_value;
            }
        }
        
        # Process arguments for calevent
        foreach ($this->calevent_field_info as $field_name => $info) {
            # These come through the file upload mechanism, so don't
            # let them come in through the normal query process.
            if ($field_name == 'image' ||
                $field_name == 'imagheight' ||
                $field_name == 'imagewidth') {

                continue;
            }

            $query_field_name = 'event_' . $field_name;

            if (isset($query_vars[$query_field_name])) {
                if ($field_name == 'editcode') {
                    $this->user_editcode = $query_vars[$query_field_name];
                }
                else {
                    $this->event_args[$field_name] = 
                        $query_vars[$query_field_name];
                }
            }
        }

        if ($this->action == "new") {
            $this->set_defaults();
        }

        $this->convert_data_types();

        if ($this->action == "update" || $this->action == "create") {
            $this->fill_in_missing_values($daily_args);
            $this->check_validity();

            if (!$this->is_valid()) {
                # Can't create or update because the event wasn't valid.
                # Go back to editing.
                #
                # @@@ This will break when creating a new event. The
                # next action will go from "edit" to "update" -- but update
                # is wrong; we want the next action to be create.
                #
                # Maybe next_action() can check to see if an event_id already
                # exists, and choose "create" or "update" appropriately.
                $this->action = "edit";
            }
            else {
                $this->calculate_days($daily_args);
                $this->attach_images();
                $this->add_event_to_db($this->event_args,
                                       $this->dayinfo['daylist']);
            }
        }
        else if ($this->action == "delete") {
            
            if ($this->is_editcode_valid()) {
                $this->delete();
            }
            else {
                $this->errors[] = "You don't have permission to delete this event.";
                $this->action = "edit";
            }
        }
    }

    protected function load_from_db() {
        global $calevent_table_name;
        global $caldaily_table_name;
        global $wpdb;

        if (!isset($this->event_id)) {
            die();
        }

        $sql = $wpdb->prepare("SELECT * FROM ${calevent_table_name} " .
                              "WHERE id=%d",
                              $this->event_id);
        $results = $wpdb->get_results($sql, ARRAY_A);
        
        if (count($results) != 1) {
            die("Wront number of DB results...");
        }
        else {
            $result = $results[0];
            foreach ($result as $db_key => $db_value) {

                if ($db_key == 'editcode') {
                    $this->db_editcode = $db_value;
                }
                else {
                    $this->event_args[$db_key] = $db_value;
                }
            }
        }

        # We don't have to load caldaily here. The fields get loaded
        # by the AJAX request in the submission form, and then passed
        # in as part of the form.
    }

    # Load just the fields that are needed for editing this
    # event.
    protected function load_modification_fields_from_db() {
        global $calevent_table_name;
        global $wpdb;

        if (!isset($this->event_id)) {
            die();
        }

        $sql = $wpdb->prepare("SELECT editcode, image FROM ${calevent_table_name} " .
                              "WHERE id=%d",
                              $this->event_id);
        $results = $wpdb->get_results($sql, ARRAY_A);
        
        if (count($results) != 1) {
            die("Wront number of DB results...");
        }
        else {
            $result = $results[0];
            $this->db_editcode = $result['editcode'];
            $this->event_args['image'] = $result['image'];
        }
    }

    # Set some values to their defaults.
    protected function set_defaults() {
        if ($this->action != 'new') {
            die();
        }

        # @@@ Add more defaults...
        $this->event_args['audience'] = 'G';
    }

    # Create values for fields that are missing because the web browser
    # didn't send them over, or because WordPress isn't reporting them
    # in the query.
    protected function fill_in_missing_values($daily_args) {
        if ($this->action != 'update' && $this->action != 'create') {
            die();
        }

        # Do missing values for event_args
        foreach ($this->calevent_field_info as $field_name => $field_info) {
            if (isset($field_info['missing_val']) &&
                !isset($this->event_args[$field_name]) ) {

                $this->event_args[$field_name] = $field_info['missing_val'];
            }
        }

        # Do missing values for daily_args
        foreach ($daily_args as $date_suffix => &$day) {
            foreach ($this->caldaily_field_info as $field_name => $field_info) {
                if (isset($field_info['missing_val']) &&
                    !isset($this->event_args[$field_name]) ) {

                    $day[$field_name] = $field_info['missing_val'];
                }
            }
        }
    }

    # Some of the data we get in from the form has to be converted before it's
    # ready to be stored to the database. Do those conversions.
    protected function convert_data_types() {
        # For these fields, convert Y/N to integer
        $field_names = array('hideemail', 'hidephone', 'emailforum', 'printemail',
                             'printphone', 'printweburl', 'hidecontact',
                             'printcontact');

        foreach ($field_names as $field_name) {
            if (isset($this->event_args[$field_name])) {
                $old_value = $this->event_args[$field_name];
                $new_value = $old_value == "Y" ? 1 : 0;
                $this->event_args[$field_name] = $new_value;
            }
        }
    }
    
    # Do an INSERT operation on the table
    protected function insert_into_table($table_name, $field_info, $args) {
        $types = Array();
        foreach ($args as $name => $value) {
            $types[] = $field_info[$name]['type'];
        }

        global $wpdb;

        $wpdb->insert($table_name,
                      $args,
                      $types);

        return $wpdb->insert_id;
    }

    # Do an UPDATE operation on the table
    protected function update_table($table_name, $field_info,
                                    $args, $where) {

        $arg_types = Array();
        foreach ($args as $name => $value) {
            $arg_types[] = $field_info[$name]['type'];
        }

        $where_types = Array();
        foreach ($where as $name => $value) {
            $where_types[] = $field_info[$name]['type'];
        }

        global $wpdb;
        $wpdb->update($table_name,
                      $args,
                      $where,
                      $arg_types,
                      $where_types);

        return;       
    }

    protected function add_event_to_db($event_args, $daylist) {
        global $calevent_table_name, $caldaily_table_name;

        if ($this->action == "create") {
            # Create the editcode
            $event_args['editcode'] = uniqid();
            $this->user_editcode = $event_args['editcode'];
            $this->db_editcode = $event_args['editcode'];

            $this->event_id =
                $this->insert_into_table($calevent_table_name,
                                    $this->calevent_field_info,
                                    $event_args);
        }
        else if ($this->action == "update") {
            # Do one last check on the editcode, for good measure.
            if (!$this->is_editcode_valid()) {
                die("Bad editcode");
            }

            $where = Array('id' => $this->event_id);

            $this->update_table($calevent_table_name,
                                $this->calevent_field_info,
                                $event_args,
                                $where);
        }
        else {
            die("Bad value for action");
        }

        foreach ($daylist as $day) {
            $caldaily_args = Array();

            # associate caldaily with calevent
            $caldaily_args['id'] = $this->event_id;

            # Populate the other fields.
            # We don't use $day directly because it has a bunch of fields
            # used for calculation that aren't stored in the database.
            foreach(Array('newsflash', 'eventdate',
                          'eventstatus', 'exceptionid') as $key) {

                if (isset($day[$key])) {
                    $caldaily_args[$key] = $day[$key];
                }
            }

            # Sometimes we end up with a day that has an eventdate &
            # not a sqldate. Evan thinks the two are interchangable, but
            # he's not sure... See the comments at the top of repeat.php,
            # about what the fields all mean.
            if (isset($day['sqldate']) && !isset($day['eventdate'])) {
                $caldaily_args['eventdate'] = $day['sqldate'];
            }

            # Figure out if we need to to a DB UPDATE or INSERT. 
            # This logic comes from the old calsubmit.php code,
            # and I don't entirely understand it. (See that file,
            # lines 425 or 270.)
            #
            # @@@ We also need to do a delete, when the
            # status is deleted?
            $event_exists = $this->action == "update";
            $day_exists   = isset($day['status']) && 
                ($day['status'] == "Added" ||
                 $day['status'] == "Skipped" ||
                 $day['status'] == "Canceled" ||
                 $day['status'] == "As Scheduled");

            if ($event_exists && $day_exists) {
                $where = Array('id' => $this->event_id,
                               'eventdate' => $day['sqldate']);

                $this->update_table($caldaily_table_name,
                                    $this->caldaily_field_info,
                                    $caldaily_args,
                                    $where);
            }
            else if ($day['status'] == 'Deleted') {
                global $wpdb;
                # We have to put $caldaily_table_name into the string,
                # because if we put it in with %s, prepare() will put
                # quotes around it, and that's a SQL error.
                $sql = $wpdb->prepare("DELETE FROM ${caldaily_table_name} " .
                                      "WHERE id=%d and eventdate=%s",
                                      $this->event_id,
                                      $day['sqldate']);

                $result = $wpdb->query($sql);
                if ($result !== 1) {
                    die("Failed to delete one of the days.");
                }
            }
            else {
                $this->insert_into_table($caldaily_table_name,
                                    $this->caldaily_field_info,
                                    $caldaily_args);
            }                                        
        }
    }

    protected function delete() {
        global $calevent_table_name;
        global $caldaily_table_name;
        global $wpdb;

        $caldaily_query = $wpdb->prepare("DELETE FROM ${caldaily_table_name} " .
                                         "WHERE id=%d OR exceptionid=%d",
                                         $this->event_id, $this->event_id);
        $result = $wpdb->query($caldaily_query);
        if ($result === false) {
            die("Failed to delete from caldaily");
        }

        $calevent_query = $wpdb->prepare("DELETE FROM ${calevent_table_name} " .
                                         "WHERE id=%d",
                                         $this->event_id);
        $result = $wpdb->query($calevent_query);
        if ($result === false) {
            die("Failed to delete from caldaily");
        }

        $this->delete_image();
    }

    protected function attach_images() {
        if (!isset($_FILES['event_image']['tmp_name'])) {
            # Nothing to do...

            # @@@ Check the error code; could be a problem on the user's
            # end.
            return;
        }

        # Copy the file to the uploads directory.

        # @@@ If we wanted to get fancy, we could pass in the date of the
        # first event, so the upload dir would correspond to the event date,
        # not the creation date (today's date).
        $upload_dirinfo = wp_upload_dir();

        var_dump($upload_dirinfo);
        
        # This trusts that the file extension is OK on the user's machine...
        $extension = pathinfo($_FILES['event_image']['name'],
                              PATHINFO_EXTENSION);
        var_dump($extension);

        $filename = $upload_dirinfo['path'] . '/' .
            uniqid() . '.' . $extension;

        move_uploaded_file($_FILES['event_image']['tmp_name'],
                           $filename);
        list($imagewidth, $imageheight) = getimagesize($filename);

        # Delete the old image (if any)
        $this->delete_image();

        # Make a filename that's relative to the uploads dir.
        # We can use this later to construct a URL.
        $relative_filename =
            str_replace($upload_dirinfo['basedir'], '', $filename);
        
        # Update the event_args
        $this->event_args['image'] = $relative_filename;
        $this->event_args['imageheight'] = $imageheight;
        $this->event_args['imagewidth'] = $imagewidth;

        var_dump($this->event_args);
        
        # (We could make a WordPress attachment out of this. But what would
        # the benefit be?)
    }

    # Delete the image file for this event, if it has one.
    protected function delete_image() {
        print "<p>Image:</p>";
        var_dump($this->event_args['image']);

        if (isset($this->event_args['image']) &&
            $this->event_args['image'] != '') {

            $upload_dirinfo = wp_upload_dir();
            $old_filename = $upload_dirinfo['basedir'] .
                $this->event_args['image'];
            
            $success = unlink($old_filename);
            if (!$success) {
                die("Can't delete image: $old_filename");
            }
        }
    }
    
    protected function is_editcode_valid() {
        if ($this->action == "edit"   ||
            $this->action == "update" ||
            $this->action == "delete") {

            if (!isset($this->db_editcode)) {
                # This shouldn't happen.
                die("Missing DB edit code");
            }

            if (!isset($this->user_editcode) ||
                $this->user_editcode != $this->db_editcode) {

                return false;
            }
        }

        return true;
    }
    
    # @@@ check for more invalid values
    protected function check_validity() {
        # @@@ Validate the dates more carefully
        if (! isset($this->event_args['dates']) ) {
            $this->errors[] = "Date is missing";
        }

        # Validate the edit code
        if (!$this->is_editcode_valid()) {
            $this->errors[] = "You don't have authorization to edit this event";
        }
    }

    public function is_valid() {
        return count($this->errors) == 0;
    }
    
    # Calculate the recurring event stuff.
    protected function calculate_days($daily_args) {
        if (!isset($this->event_args['dates'])) {
            die();
        }

        # parse the $dates value, and convert it to a list of specific dates
        $this->dayinfo = repeatdates($this->event_args['dates']);

        # Store the type of date (sequential, scattered, etc.)
        # But we only store the first letter in the DB.
        $this->event_args['datestype'] =
            strtoupper(substr($this->dayinfo['datestype'], 0, 1));

        if ($this->action == "update") {
            # Fetch the old dates
            $olddates = dailystatus($this->event_id);

            # Merge the old and new lists.
            $this->dayinfo['daylist'] =
                mergedates($this->dayinfo['daylist'], $olddates);
        }
        else if ($this->action == "create") {
            # all dates will be added
            foreach ($this->dayinfo['daylist'] as $day) {
                $day['changed'] = 'Y';
                $day['olddate'] = 'N';
            }
        }
        else {
            die("Bad value for action");
        }

        # Add values for status & newsflash from the query
        # parameters. Use a reference to $day, to let us
        # modify the values.
        foreach ($this->dayinfo['daylist'] as &$day) {
            $suffix = $day['suffix'];

            if (isset($daily_args[$suffix]['newsflash'])) {
                $day['newsflash'] = $daily_args[$suffix]['newsflash'];
            }

            if (isset($daily_args[$suffix]['status'])) {
                $day['status'] = $daily_args[$suffix]['status'];
                $day['eventstatus'] = statusname($day['status']);
            }
        }
    }

    # @@@ Sanitize these outputs
    private function print_value_for_text_input($argname) {
        if (isset($this->event_args[$argname])) {
            printf("value=\"%s\"", $this->event_args[$argname]);
        }
    }

    public function print_title() {
        $this->print_value_for_text_input('title');
    }

    public function print_tinytitle() {
        $this->print_value_for_text_input('tinytitle');
    }

    public function print_locname() {
        $this->print_value_for_text_input('locname');
    }

    public function print_locdetails() {
        $this->print_value_for_text_input('locdetails');
    }

    public function print_address() {
        $this->print_value_for_text_input('address');
    }

    public function print_dates() {
        $this->print_value_for_text_input('dates');
    }

    public function print_timedetails() {
        $this->print_value_for_text_input('timedetails');
    }

    public function print_name() {
        $this->print_value_for_text_input('name');
    }
    
    public function print_phone() {
        $this->print_value_for_text_input('phone');
    }

    public function print_email() {
        $this->print_value_for_text_input('email');
    }

    public function print_weburl() {
        $this->print_value_for_text_input('weburl');
    }

    public function print_webname() {
        $this->print_value_for_text_input('webname');
    }

    public function print_contact() {
        $this->print_value_for_text_input('contact');
    }
    
    public function print_descr() {
        if (isset($this->event_args['descr'])) {
            print $this->event_args['descr'];
        }
    }

    private function print_checked_for_audience($audience) {
        if (isset($this->event_args['audience']) &&
            $this->event_args['audience'] == $audience) {

            print "checked";
        }
    }
    
    public function print_checked_for_family_audience() {
        $this->print_checked_for_audience('F');
    }

    public function print_checked_for_general_audience() {
        $this->print_checked_for_audience('G');
    }

    public function print_checked_for_adult_audience() {
        $this->print_checked_for_audience('A');
    }

    public function print_checked_for_hideemail() {
        if (isset($this->event_args['hideemail']) &&
            $this->event_args['hideemail']) {

            print "checked";
        }
    }

    public function print_checked_for_hidephone() {
        if (isset($this->event_args['hidephone']) &&
            $this->event_args['hidephone']) {

            print "checked";
        }
    }

    public function print_checked_for_hidecontact() {
        if (isset($this->event_args['hidecontact']) &&
            $this->event_args['hidecontact']) {

            print "checked";
        }
    }

    public function print_selected_for_eventtime($time) {
        if (!isset($this->event_args['eventtime']) && $time == "") {

            # The default value of eventtime is empty string.
            # (that's the value that represents 'Choose a time' in the
            # SELECT drop-down

            print "selected";
        }
        else if (isset($this->event_args['eventtime']) &&
                 $this->event_args['eventtime'] == $time) {

            print "selected";
        }

        # Otherwise this isn't selected. Print nothing.
    }

    public function print_selected_for_duration($duration) {
        if (!isset($this->event_args['duration']) &&
            $duration == "0") {

            # 0 (unspecified) is selected by default
            print "selected";
        }
        else if (isset($this->event_args['duration']) &&
                 $this->event_args['duration'] == $duration) {

            print "selected";
        }

        # Otherwise this isn't selected. Print nothing.
    }

    public function current_action() {
        return $this->action;
    }

    public function has_event_id() {
        return isset($this->event_id);
    }

    public function event_id() {
        return $this->event_id;
    }

    public function has_editcode() {
        return isset($this->db_editcode);
    }

    public function editcode() {
        if (!$this->is_editcode_valid()) {
            die("Missing authorization to edit this entry");
        }

        return $this->user_editcode;
    }

    public function has_delete() {
        return $this->action == "edit";
    }

    # Return the action to perform next.
    # This should only be called from the edit-event
    # page.
    public function next_action() {
        if ($this->action == "new") {
            return "create";
        }
        else if ($this->action == "edit") {
            return "update";
        }
        else {
            die("next_action() should not have been called");
        }
    }

    public function print_errors() {
        if (!$this->is_valid()) {
            print "<ul>\n";

            foreach ($this->errors as $error) {
                print "<li>";
                print $error;
                print "</li>";
            }
            
            print "</ul>\n";
        }
    }

    # What kind of page should the caller show?
    #
    # edit-event     -- Show the form for making/updating an event
    # event-updated  -- Show the results of making/updating an event
    # event-deleted  -- Show the results of deleting an event
    public function page_to_show() {
        if ($this->action == "new" ||
            $this->action == "edit") {

            return "edit-event";
        }
        else if ($this->action == "create" ||
                 $this->action == "update") {

            return "event-updated";
        }
        else if ($this->action == "delete") {
            return "event-deleted";
        }
        else {
            die("Bad action: $this->action");
        }
    }
}
?>